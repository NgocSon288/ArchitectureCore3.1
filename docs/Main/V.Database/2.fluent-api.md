# Dùng [Fluent-API] thay cho [Atrribute] (Dependentcy)
- Tạo các file [Configuration] cho mỗi [Entity] tương ứng, và các class đó phải kế thừa từ [IEntityTypeConfiguration<Product>], và implement phương thức [Configure]
    <!-- 
        class ProductConfiguration : IEntityTypeConfiguration<Product>
        {
            public void Configure(EntityTypeBuilder<Product> builder)
            {
                builder.ToTable("AppConfigs");

                builder.HasKey(p => p.Key);

                builder.Property(p => p.Value)
                    .IsRequired(true);
            }
        } 
    -->

- Cần [Override] phương thức [OnModelCreating] trong [DbContext]
    - Ta có thể [Config] trực tiếp vào đối tượng [modelBuilder] 
        <!-- modelBuilder.Entity<Product>().Property(t => t.ProductDate).IsRequired(); -->
    - Nhưng khi nhiều [Entity] thì rất khó nhìn, nên tách file riêng, và khai báo lại trong phương thức [OnModelCreating]
        <!-- modelBuilder.ApplyConfiguration(new ProductConfiguration()); -->


# Some Fluent API
- [ToTable("abc")] tên bảng
- [HasKey(e=>e.ID)] khóa chính

- [HasIndex(e=>e.Name)] tạo index
- [IsUnique(true)] thiết lập Unique

- [Property(p=>p.ID)] thiết lập cho thuộc tính
- [IsRequired()] có required hay không
- [HasDefaultValue(100)]  chỉ  ra giá trị mặc định cho thuộc tính
- [HasOne(e=>e.Loai)] chỉ ra entity key phía một
- [WithMany(p=>p.HangHoas)] chỉ ra Collection phía nhiều
- [HasForeignKey(e=>e.MaLoai)] chỉ ra tên FK
- [OnDelete(DeleteBehavior.SetNull)] ứng xử khi xóa
- [HasConstraintName("FK_HangHoa_Loai")] đặt tên FK
- [HasMaxLength(50)]


# Relationship
## Many to Many
- [Entity] Tạo bảng [ProductInCategory] để liên kết giữa 2 bảng. Có chứa 2 khóa chính của 2 bảng. Thêm thuộc tính [List<ProductInCategory>] vào cả 2 bảng [Product] và [Category]
- [Configuration] chỉ ra 2 ID thay vì 1 như bình thường
    <!-- builder.HasKey(t => new {t.CategoryID, t.PeroductID}) -->  // Chỉ ra 2 FK

    <!-- 
        builder.HasOne(pc => pc.Product)
            .WithMany(p => p.ProductInCategories)
            .HasForeignKey(pc => pc.ProductID) 

        builder.HasOne(pc => pc.Category)
            .WithMany(p => p.ProductInCategories)
            .HasForeignKey(pc => pc.CategoryID)
    -->

## One to Many
- [Entity] bên nhiều sẽ chứa danh sách các một, bên một sẽ chưa một [Object] bên nhiều. Giả sử [Order] sẽ có [List<OrderDetail>], bên [OrderDetailt] sẽ có [Order]
- [Configuration] ta cấu hình bên [OrderDetailtConfiguration]
    <!-- 
        builder.HasOne(od => od.Order)
            .WithMany(o => o.OrderDetailts)
            .HasForeignKey(od => od.OrderID)
    -->

# Dùng SeedData 
- Để khởi tạo ra các data ban đầu bằng cách dùng phương thức [HasData()] như cách ta connfig các thuộc tính, bảng bằng [FluentAPI]
- Có thể tạo file  extension để gọi
- Sau đó dùng lệnh cập nhật DB bình thường
    <!-- 
        dotnet ef migrations add Initial_DataSeed
        dotnet ef database update 
    -->
- Có thể xuất hiện các lỗi do các Insert data khác với các bình thường
    - Các Object phải có ID <!-- Can not be add nonn-zero value is required for property id -->
    - Không khai báo lồng nhau